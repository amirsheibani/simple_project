// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'my_ip_bloc_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$MyIpBlocState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() idle,
    required TResult Function() loading,
    required TResult Function(IpEntity? data) success,
    required TResult Function(String? message) failed,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? idle,
    TResult? Function()? loading,
    TResult? Function(IpEntity? data)? success,
    TResult? Function(String? message)? failed,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? idle,
    TResult Function()? loading,
    TResult Function(IpEntity? data)? success,
    TResult Function(String? message)? failed,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MyIpBlocStateIdle value) idle,
    required TResult Function(MyIpBlocStateLoading value) loading,
    required TResult Function(MyIpBlocStateSuccess value) success,
    required TResult Function(MyIpBlocStateFailed value) failed,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MyIpBlocStateIdle value)? idle,
    TResult? Function(MyIpBlocStateLoading value)? loading,
    TResult? Function(MyIpBlocStateSuccess value)? success,
    TResult? Function(MyIpBlocStateFailed value)? failed,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MyIpBlocStateIdle value)? idle,
    TResult Function(MyIpBlocStateLoading value)? loading,
    TResult Function(MyIpBlocStateSuccess value)? success,
    TResult Function(MyIpBlocStateFailed value)? failed,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MyIpBlocStateCopyWith<$Res> {
  factory $MyIpBlocStateCopyWith(
          MyIpBlocState value, $Res Function(MyIpBlocState) then) =
      _$MyIpBlocStateCopyWithImpl<$Res, MyIpBlocState>;
}

/// @nodoc
class _$MyIpBlocStateCopyWithImpl<$Res, $Val extends MyIpBlocState>
    implements $MyIpBlocStateCopyWith<$Res> {
  _$MyIpBlocStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$MyIpBlocStateIdleCopyWith<$Res> {
  factory _$$MyIpBlocStateIdleCopyWith(
          _$MyIpBlocStateIdle value, $Res Function(_$MyIpBlocStateIdle) then) =
      __$$MyIpBlocStateIdleCopyWithImpl<$Res>;
}

/// @nodoc
class __$$MyIpBlocStateIdleCopyWithImpl<$Res>
    extends _$MyIpBlocStateCopyWithImpl<$Res, _$MyIpBlocStateIdle>
    implements _$$MyIpBlocStateIdleCopyWith<$Res> {
  __$$MyIpBlocStateIdleCopyWithImpl(
      _$MyIpBlocStateIdle _value, $Res Function(_$MyIpBlocStateIdle) _then)
      : super(_value, _then);
}

/// @nodoc

class _$MyIpBlocStateIdle implements MyIpBlocStateIdle {
  const _$MyIpBlocStateIdle();

  @override
  String toString() {
    return 'MyIpBlocState.idle()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$MyIpBlocStateIdle);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() idle,
    required TResult Function() loading,
    required TResult Function(IpEntity? data) success,
    required TResult Function(String? message) failed,
  }) {
    return idle();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? idle,
    TResult? Function()? loading,
    TResult? Function(IpEntity? data)? success,
    TResult? Function(String? message)? failed,
  }) {
    return idle?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? idle,
    TResult Function()? loading,
    TResult Function(IpEntity? data)? success,
    TResult Function(String? message)? failed,
    required TResult orElse(),
  }) {
    if (idle != null) {
      return idle();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MyIpBlocStateIdle value) idle,
    required TResult Function(MyIpBlocStateLoading value) loading,
    required TResult Function(MyIpBlocStateSuccess value) success,
    required TResult Function(MyIpBlocStateFailed value) failed,
  }) {
    return idle(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MyIpBlocStateIdle value)? idle,
    TResult? Function(MyIpBlocStateLoading value)? loading,
    TResult? Function(MyIpBlocStateSuccess value)? success,
    TResult? Function(MyIpBlocStateFailed value)? failed,
  }) {
    return idle?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MyIpBlocStateIdle value)? idle,
    TResult Function(MyIpBlocStateLoading value)? loading,
    TResult Function(MyIpBlocStateSuccess value)? success,
    TResult Function(MyIpBlocStateFailed value)? failed,
    required TResult orElse(),
  }) {
    if (idle != null) {
      return idle(this);
    }
    return orElse();
  }
}

abstract class MyIpBlocStateIdle implements MyIpBlocState {
  const factory MyIpBlocStateIdle() = _$MyIpBlocStateIdle;
}

/// @nodoc
abstract class _$$MyIpBlocStateLoadingCopyWith<$Res> {
  factory _$$MyIpBlocStateLoadingCopyWith(_$MyIpBlocStateLoading value,
          $Res Function(_$MyIpBlocStateLoading) then) =
      __$$MyIpBlocStateLoadingCopyWithImpl<$Res>;
}

/// @nodoc
class __$$MyIpBlocStateLoadingCopyWithImpl<$Res>
    extends _$MyIpBlocStateCopyWithImpl<$Res, _$MyIpBlocStateLoading>
    implements _$$MyIpBlocStateLoadingCopyWith<$Res> {
  __$$MyIpBlocStateLoadingCopyWithImpl(_$MyIpBlocStateLoading _value,
      $Res Function(_$MyIpBlocStateLoading) _then)
      : super(_value, _then);
}

/// @nodoc

class _$MyIpBlocStateLoading implements MyIpBlocStateLoading {
  const _$MyIpBlocStateLoading();

  @override
  String toString() {
    return 'MyIpBlocState.loading()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$MyIpBlocStateLoading);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() idle,
    required TResult Function() loading,
    required TResult Function(IpEntity? data) success,
    required TResult Function(String? message) failed,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? idle,
    TResult? Function()? loading,
    TResult? Function(IpEntity? data)? success,
    TResult? Function(String? message)? failed,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? idle,
    TResult Function()? loading,
    TResult Function(IpEntity? data)? success,
    TResult Function(String? message)? failed,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MyIpBlocStateIdle value) idle,
    required TResult Function(MyIpBlocStateLoading value) loading,
    required TResult Function(MyIpBlocStateSuccess value) success,
    required TResult Function(MyIpBlocStateFailed value) failed,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MyIpBlocStateIdle value)? idle,
    TResult? Function(MyIpBlocStateLoading value)? loading,
    TResult? Function(MyIpBlocStateSuccess value)? success,
    TResult? Function(MyIpBlocStateFailed value)? failed,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MyIpBlocStateIdle value)? idle,
    TResult Function(MyIpBlocStateLoading value)? loading,
    TResult Function(MyIpBlocStateSuccess value)? success,
    TResult Function(MyIpBlocStateFailed value)? failed,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class MyIpBlocStateLoading implements MyIpBlocState {
  const factory MyIpBlocStateLoading() = _$MyIpBlocStateLoading;
}

/// @nodoc
abstract class _$$MyIpBlocStateSuccessCopyWith<$Res> {
  factory _$$MyIpBlocStateSuccessCopyWith(_$MyIpBlocStateSuccess value,
          $Res Function(_$MyIpBlocStateSuccess) then) =
      __$$MyIpBlocStateSuccessCopyWithImpl<$Res>;
  @useResult
  $Res call({IpEntity? data});
}

/// @nodoc
class __$$MyIpBlocStateSuccessCopyWithImpl<$Res>
    extends _$MyIpBlocStateCopyWithImpl<$Res, _$MyIpBlocStateSuccess>
    implements _$$MyIpBlocStateSuccessCopyWith<$Res> {
  __$$MyIpBlocStateSuccessCopyWithImpl(_$MyIpBlocStateSuccess _value,
      $Res Function(_$MyIpBlocStateSuccess) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? data = freezed,
  }) {
    return _then(_$MyIpBlocStateSuccess(
      data: freezed == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as IpEntity?,
    ));
  }
}

/// @nodoc

class _$MyIpBlocStateSuccess implements MyIpBlocStateSuccess {
  const _$MyIpBlocStateSuccess({this.data});

  @override
  final IpEntity? data;

  @override
  String toString() {
    return 'MyIpBlocState.success(data: $data)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MyIpBlocStateSuccess &&
            (identical(other.data, data) || other.data == data));
  }

  @override
  int get hashCode => Object.hash(runtimeType, data);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MyIpBlocStateSuccessCopyWith<_$MyIpBlocStateSuccess> get copyWith =>
      __$$MyIpBlocStateSuccessCopyWithImpl<_$MyIpBlocStateSuccess>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() idle,
    required TResult Function() loading,
    required TResult Function(IpEntity? data) success,
    required TResult Function(String? message) failed,
  }) {
    return success(data);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? idle,
    TResult? Function()? loading,
    TResult? Function(IpEntity? data)? success,
    TResult? Function(String? message)? failed,
  }) {
    return success?.call(data);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? idle,
    TResult Function()? loading,
    TResult Function(IpEntity? data)? success,
    TResult Function(String? message)? failed,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success(data);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MyIpBlocStateIdle value) idle,
    required TResult Function(MyIpBlocStateLoading value) loading,
    required TResult Function(MyIpBlocStateSuccess value) success,
    required TResult Function(MyIpBlocStateFailed value) failed,
  }) {
    return success(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MyIpBlocStateIdle value)? idle,
    TResult? Function(MyIpBlocStateLoading value)? loading,
    TResult? Function(MyIpBlocStateSuccess value)? success,
    TResult? Function(MyIpBlocStateFailed value)? failed,
  }) {
    return success?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MyIpBlocStateIdle value)? idle,
    TResult Function(MyIpBlocStateLoading value)? loading,
    TResult Function(MyIpBlocStateSuccess value)? success,
    TResult Function(MyIpBlocStateFailed value)? failed,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success(this);
    }
    return orElse();
  }
}

abstract class MyIpBlocStateSuccess implements MyIpBlocState {
  const factory MyIpBlocStateSuccess({final IpEntity? data}) =
      _$MyIpBlocStateSuccess;

  IpEntity? get data;
  @JsonKey(ignore: true)
  _$$MyIpBlocStateSuccessCopyWith<_$MyIpBlocStateSuccess> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$MyIpBlocStateFailedCopyWith<$Res> {
  factory _$$MyIpBlocStateFailedCopyWith(_$MyIpBlocStateFailed value,
          $Res Function(_$MyIpBlocStateFailed) then) =
      __$$MyIpBlocStateFailedCopyWithImpl<$Res>;
  @useResult
  $Res call({String? message});
}

/// @nodoc
class __$$MyIpBlocStateFailedCopyWithImpl<$Res>
    extends _$MyIpBlocStateCopyWithImpl<$Res, _$MyIpBlocStateFailed>
    implements _$$MyIpBlocStateFailedCopyWith<$Res> {
  __$$MyIpBlocStateFailedCopyWithImpl(
      _$MyIpBlocStateFailed _value, $Res Function(_$MyIpBlocStateFailed) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = freezed,
  }) {
    return _then(_$MyIpBlocStateFailed(
      message: freezed == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$MyIpBlocStateFailed implements MyIpBlocStateFailed {
  const _$MyIpBlocStateFailed({this.message});

  @override
  final String? message;

  @override
  String toString() {
    return 'MyIpBlocState.failed(message: $message)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MyIpBlocStateFailed &&
            (identical(other.message, message) || other.message == message));
  }

  @override
  int get hashCode => Object.hash(runtimeType, message);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MyIpBlocStateFailedCopyWith<_$MyIpBlocStateFailed> get copyWith =>
      __$$MyIpBlocStateFailedCopyWithImpl<_$MyIpBlocStateFailed>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() idle,
    required TResult Function() loading,
    required TResult Function(IpEntity? data) success,
    required TResult Function(String? message) failed,
  }) {
    return failed(message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? idle,
    TResult? Function()? loading,
    TResult? Function(IpEntity? data)? success,
    TResult? Function(String? message)? failed,
  }) {
    return failed?.call(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? idle,
    TResult Function()? loading,
    TResult Function(IpEntity? data)? success,
    TResult Function(String? message)? failed,
    required TResult orElse(),
  }) {
    if (failed != null) {
      return failed(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MyIpBlocStateIdle value) idle,
    required TResult Function(MyIpBlocStateLoading value) loading,
    required TResult Function(MyIpBlocStateSuccess value) success,
    required TResult Function(MyIpBlocStateFailed value) failed,
  }) {
    return failed(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MyIpBlocStateIdle value)? idle,
    TResult? Function(MyIpBlocStateLoading value)? loading,
    TResult? Function(MyIpBlocStateSuccess value)? success,
    TResult? Function(MyIpBlocStateFailed value)? failed,
  }) {
    return failed?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MyIpBlocStateIdle value)? idle,
    TResult Function(MyIpBlocStateLoading value)? loading,
    TResult Function(MyIpBlocStateSuccess value)? success,
    TResult Function(MyIpBlocStateFailed value)? failed,
    required TResult orElse(),
  }) {
    if (failed != null) {
      return failed(this);
    }
    return orElse();
  }
}

abstract class MyIpBlocStateFailed implements MyIpBlocState {
  const factory MyIpBlocStateFailed({final String? message}) =
      _$MyIpBlocStateFailed;

  String? get message;
  @JsonKey(ignore: true)
  _$$MyIpBlocStateFailedCopyWith<_$MyIpBlocStateFailed> get copyWith =>
      throw _privateConstructorUsedError;
}
